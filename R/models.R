#' Estimate a GAM (generalized additive  model) on the given data
#' The function takes one argument, an environment.  The following are
#' the elements expected in the environment
#' @param Data = a data frame containing the variables promised in the formula
#' @param Formula = the formula used to generate fit
#' @return nothing, but update the environment with a new item:
#' Fit = an object of class 'tree', giving the fit.

TEA.gam.est <- function(env){
	Fit <- try(gam(env$Formula,data=env$Data))
	if(inherits(Fit,"try-error")) stop(paste("gam on", env$Formula, "did not work for given data"))
	env$Fit <- Fit
	env$Newdata <- env$Data #set new data to data used for fit; user can modify this
}

#' Draw synthetic values from a GAM fit, using predictive mean matching.
#' The function takes one argument, an environment.  The following are
#' the elements expected in the environment
#' @param Data = a data frame containing the variables promised in the formula
#' @param Formula = the formula used to generate fit
#' @param Fit = an object of class 'tree' giving the fit
#' @return a vector containing the synthetic values

TEA.gam.draw <- function(env){
	lhs  <- all.vars(env$Formula)[1]
	originals <- env$Data[,lhs] #store original non-missing values from data used for FIT
	vwch <- which(!is.na(originals))
	originals <- originals[vwch]
	#predicted from original data non-missing
	opredicted <- predict.gam(env$Fit,newdata=env$Data[vwch,],type="link")
	#predicted from NEW data
	npredicted <- predict.gam(env$Fit,newdata=env$Newdata,type="link")
	#all predicted together
	predicted <- c(opredicted,npredicted)
	if(inherits(predicted,"try-error")) stop("prediction not successful")
	dists <- as.matrix(dist(predicted)) #get distances of fitted valued
	diag(dists) <- Inf #set diagonal to infinity
	dists[is.na(dists)] <- Inf #set NA values to infinity
	#take off rows for original data
	dists <- dists[-(1:length(opredicted)),]
	#take off columns for newdata
	dists <- dists[,-(1:length(npredicted))]
	#find maximal -distance, so minimal distance. diag is inf, so will never be minimal
	donors <- max.col(-dists)
	donvals <- originals[donors]
	ret <- env$Newdata
	ret[,lhs] <- donvals
	return(ret)
}

teagam <- new("apop_model", name="teagam",  
                                estimate_function=TEA.gam.est,
                                draw_function=TEA.gam.draw)

#' Given a model formula and a data frame, fit a multinomial model
#' via the MCMCmnl() function and return a list of items to be used
#' by TEA.predict.MCMCmnl
#' @param Formula = a formula object
#' @param Data = a data frame on which to perform modeling
#' @return a list containing the following named items
#' Fit: a matrix of posterior parameter draws returned by MCMCmnl
#' Formula: the formula given as an argument
#' Mmod: a model matrix generated by model.matrix(multinom(Formula,Data))
#' Llev: the levels/unique values for every factor/character variable referenced in Formula

#TEA.fit.MCMCmnl <- function(Formula,Data){
TEA.MCMCmnl.est <- function(env){
	#all variables
	Vvar <- all.vars(env$Formula)
	env$Data <- env$Data[,Vvar]
#	#make character lhs a factor; this helps MCMCmnl get the names right!
#	env$Data <- as.data.frame(lapply(env$Data[,Vvar],
#		function(x) if(is.character(x)) return(factor(x)) else return(x)))

	#function to get all factor levels in the original fit
	flev <- function(var){
		if(is.character(env$Data[,var])) return(levels(factor(env$Data[,var])))
		else if(is.factor(env$Data[,var])) return(levels(env$Data[,var]))
		return(NA)
	}
    env$Llev <- sapply(Vvar,flev)

	env$Fit <- try(MCMCmnl(env$Formula,data=env$Data))
	if(inherits(env$Fit,"try-error")){
		save(Data,file="err_data.RData",envir=env)
		stop(paste("MCMCmnl() on", env$Formula, "did not work for given data"))
	}
	env$Mmod <- model.matrix(env$Formula,env$Data)
	env$Newdata <- env$Data #set new data to data used for fit; user can modify this
}

#' Draw posterior predictive values from an MCMCmnl fit.
#' Made to work nicely with a return object from TEA.fit.MCMCmnl
#' (via do.call() by addition of a "DFsub" element to the list returned by TEA.fit.MCMCnl),
#' but can be used manually.
#' @param Fit = a matrix of posterior parameter draws returned by MCMCmnl
#' @param Formula = the formula used to generate Fit
#' @param Mmod = a model matrix, typically generated by model.matrix(),
#' but can be any matrix that has column names conforming to Formula.
#' @param Llev = the levels/unique values for every factor/character variable referenced in Formula.
#' Used to match levels of predicted data with that of the fitting data.  New levels in
#' predicted data will cause an error; missing levels will accounted for.
#' @param kzero = logical constant.  If TRUE, negative probabilities will be set to 0 and the set of probabilities
#' re-weighted.  If FALSE, errors due to negative probabilities will occur.
#' @return a vector containing the posterior predictive draws

#TEA.predict.MCMCmnl <- function(Fit,Formula,Mmod,Llev,DFsub,kzero=TRUE){
TEA.MCMCmnl.draw <- function(env){
	if(nrow(env$Newdata)==0) stop("Newdata has 0 rows")
	if(is.null(env$kzero)) env$kzero <- TRUE
    flev <- function(var){
        Vret <- env$Newdata[,var]
        Lret <- list(Vret)
        names(Lret) <- var
        if(is.character(env$Newdata[,var])) Vsub <- levels(factor(env$Newdata[,var]))
        else if(is.factor(env$Newdata[,var])) Vsub <- levels(env$Newdata[,var])
        #if a numeric var, just return values
        else return(Lret)
        #see if there are new levels
        Vvar <- env$Llev[[var]]
        if(is.null(Vvar)) stop("Couldn't find variable",var,"in levels list")
        if(length(setdiff(Vsub,Vvar))>0) stop(paste("New levels found for",var,"in prediction data set"))
        #add missing levels
        if(length(setdiff(Vvar,Vsub))>0){
            #Vret <- factor(env$Newdata[,var],levels=c(levels(factor(env$Newdata[,var])),setdiff(Vvar,Vsub)))
            Vret <- factor(env$Newdata[,var],levels=Vvar)
            Lret <- list(Vret)
            names(Lret) <- var
            return(Lret)
        }
        else return(Lret)
    }
	#browser()
	Vvar <- all.vars(env$Formula)
#	env$Newdata <- as.data.frame(lapply(env$Newdata[,Vvar],
#		function(x) if(is.character(x)) return(factor(x)) else return(x)))
	#trim off response from formula so model.matrix works
	newform <- as.formula(paste("~",paste(all.vars(env$Formula)[-1],collapse="+")))
	#do level check on each character/factor variable
	checkdata <- as.data.frame(lapply(all.vars(newform),flev))
	Msub <- TEAConformMatrix(model.matrix(newform,checkdata),env$Mmod)

	#get parameter rows; these are constant across response levels
	#Vrow <- sample(1:nrow(Fit),nrow(Msub),replace=TRUE)
	#same row for all!
	#Vrow <- rep(RapopModelDraw(env$parameterModel),nrow(Msub))
	Vrow <- rep(sample(1:nrow(env$Fit),1),nrow(Msub))
	#do prediction for a single response level
	#leave out first level of response
	Vlev <- env$Llev[[all.vars(env$Formula)[1]]]
    Mp <- NULL
	for(ldx in 2:length(Vlev)){
		klev <- Vlev[ldx]
		#don't grep, use dimensions
#		Vcol <- grep(paste("[.]",klev,sep=""),colnames(env$Fit))
		Vcol <- ((1:ncol(env$Fit))-(ldx-1))%%(length(Vlev)-1)==0
		#params for each row
		Mlev <- env$Fit[Vrow,Vcol]
		if(nrow(Msub)==1) Mlev <- t(matrix(Mlev)) #handle vector beta for a single row
		Vlogits <- diag(Msub %*% t(Mlev)) #logits
		#OVERFLOW MUCH!?
#		Vp <- exp(Vlogits)/(1+exp(Vlogits)) #probs for this outcome
		Vp <- (exp(-Vlogits)+1)^(-1)
		Mp <- cbind(Mp,Vp) #append to prob matrix
	}
	Mp <- cbind(1-rowSums(Mp),Mp) #complete prob matrix
    if(sum(ls(env)=="kzero")!=0 && env$kzero){
		Mp[Mp<0] <- 0
		Mp <- Mp/rowSums(Mp)
	}
	#browser()
	Vdraw <- apply(Mp,1,function(Vp) return(sample(Vlev,1,prob=Vp)))

	lhs <- all.vars(env$Formula)[1]
	DFret <- env$Newdata
	DFret[,lhs] <- Vdraw
	return(DFret)
}

mcmc.mnl <- new("apop_model", name="MCMC multinomial",  
                                estimate_function=TEA.MCMCmnl.est, 
                                draw_function=TEA.MCMCmnl.draw)

#' Estimate a CART model on the given data
#' The function takes one argument, an environment.  The following are
#' the elements expected in the environment
#' @param data = a data frame containing the variables promised in the formula
#' @param formula = the formula used to generate fit
#' @return nothing, but update the environment with a new item:
#' fit = an object of class 'tree', giving the fit.

TEA.tree.est <- function(env){
	ffact <- function(x){
		if(is.character(x)) return(factor(x))
		else return(x)
	}
	env$Data <- as.data.frame(lapply(env$Data,ffact)) #factorize characters
	env$fit <- try(tree(env$Formula,data=env$Data,y=TRUE))
	if(inherits(env$fit,"try-error")) stop(paste("Tree fit did not work on"))
	env$Newdata <- env$Data
}

#' Draw synthetic values from a CART fit, usin Reiter's Bayesian bootstrap method
#' The function takes one argument, an environment.  The following are
#' the elements expected in the environment
#' @param data = a data frame containing the variables promised in the formula
#' @param formula = the formula used to generate fit
#' @param fit = an object of class 'tree' giving the fit
#' @return a vector containing the synthetic values

TEA.tree.draw <- function(env){
	ffact <- function(x){
		if(is.character(x)) return(factor(x))
		else return(x)
	}
	env$Newdata <- as.data.frame(lapply(env$Newdata,ffact)) #factorize characters
	#leaves for donor data
	vDwhere <- predict.tree(env$fit,env$Data,type="where")
	#leaves for newdata
	vNwhere <- predict.tree(env$fit,env$Newdata,type="where")

	#do some prediction via Bayes Bootstrap
	#find all observations in a given leaf
	#get all leaves
	#TODO
	#can use y from fit to get values for donors, but then
	#have to make sure length is right!
	#donors values from fit
	vdon <- env$fit$y
	if(is.factor(vdon)) vdon <- as.character(vdon)
	#values to put into Newdata
	vret <- rep(NA,nrow(env$Newdata))
	#all the leaves
	vleaf <- row.names(subset(env$fit$frame,var=="<leaf>"))
	for(kleaf in vleaf){
		#vwch <- which(rownames(env$fit$frame)[env$fit$where]==kleaf)
		#donor values to pick from
		vDwch <- which(rownames(env$fit$frame)[vDwhere]==kleaf)
		#new values to replace
		vNwch <- which(rownames(env$fit$frame)[vNwhere]==kleaf)
		vvals <- vdon[vDwch]
		vsyn <- NULL
		#do Bayes bootstrap of donor values in node
		#not sure if draw of sampling probs occurs just once per leaf...
		vunif <- c(0,runif(length(vvals)-1,0,1),1)
		vunif <- vunif[order(vunif)]
		#repeat this until you get all the values you need
		idx <- 0
		while(idx < length(vvals)){
			vuimp <- runif(length(vvals),0,1)
			vlow <- vuimp > vunif[-length(vunif)]
			vhi <- vuimp <= vunif[-1]
			vimp <- vlow & vhi
			vsyn <- c(vsyn,vvals[vimp])
			idx <- idx + sum(vimp)
		}
#		vsyn <- vsyn[1:length(vvals)] #chop off excess imputes
		vsyn <- vsyn[1:length(vNwch)] #chop off excess imputes
		vret[vNwch] <- vsyn
	}
	ret <- env$Newdata
	lhs <- all.vars(env$Formula)[1]
	ret[,lhs] <- vret
	return(ret)
}

teatree <- new("apop_model", name="teatree",  
                                estimate_function=TEA.tree.est,
                                draw_function=TEA.tree.draw)



#' Given a model formula and a data frame, fit a linear regression model
#' via the MCMCregress() function and return a list of items to be used
#' by TEA.predict.MCMCregress
#' @param Formula = a formula object
#' @param Data = a data frame on which to perform modeling
#' @return a list containing the following named items
#' Fit: a matrix of posterior parameter draws returned by MCMCregress
#' Formula: the formula given as an argument
#' Mmod: a model matrix generated by model.matrix(lm(Formula,Data))
#' Llev: the levels/unique values for every factor/character variable referenced in Formula
TEA.MCMCregress.est <- function(env){
	env$Fit <- try(MCMCregress(env$Formula,data=env$Data))
	if(inherits(env$Fit,"try-error")) stop(paste("MCMCregress() on",env$Formula,"did not work for given data"))
	Fitml <- try(lm(env$Formula, data=env$Data))
	if(inherits(env$Fit,"try-error")) stop(paste("lm() on",Formula,"did not work for given data"))
	#model matrix
	env$Mmod <- model.matrix(Fitml)
	#levels of response
	Vvar <- all.vars(env$Formula)
	flev <- function(var, Data){
		if(is.character(Data[,var])) return(levels(factor(Data[,var])))
		if(is.factor(Data[,var])) return(levels(Data[,var]))
		return(NA)
	}
	env$Llev <- sapply(Vvar,flev, env$Data)
	env$Newdata <- env$Data #set new data to data used for fit; user can modify this
}

#' Draw posterior predictive values from an MCMCregress fit.
#' Made to work nicely with a return object from TEA.fit.MCMCregress
#' (via do.call() by addition of a "DFsub" element to the list returned by TEA.fit.MCMCregress),
#' but can be used manually.
#' @param Fit = a matrix of posterior parameter draws returned by MCMCregress
#' @param Formula = the formula used to generate Fit
#' @param Mmod = a model matrix, typically generated by model.matrix(),
#' but can be any matrix that has column names conforming to Formula.
#' @param Llev = the levels/unique values for every factor/character variable referenced in Formula.
#' Used to match levels of predicted data with that of the fitting data.  New levels in
#' predicted data will cause an error; missing levels will accounted for.
#' @param fround = a function with which to round the draws; defaults to floor
#' @return a vector containing the posterior predictive draws
TEA.MCMCregress.draw <- function(env){
	if(nrow(env$Newdata)==0) stop("Newdata has 0 rows")
	if(is.null(env$fround)) fround <- floor
    flev <- function(var){
        Vret <- env$Newdata[,var]
        Lret <- list(Vret)
        names(Lret) <- var
        if(is.character(env$Newdata[,var])) Vsub <- levels(factor(env$Newdata[,var]))
        else if(is.factor(env$Newdata[,var])) Vsub <- levels(env$Newdata[,var])
        #if a numeric var, just return values
        else return(Lret)
        #see if there are new levels
        Vvar <- env$Llev[[var]]
        if(is.null(Vvar)) stop("Couldn't find variable",var,"in levels list")
        if(length(setdiff(Vsub,Vvar))>0) stop(paste("New levels found for",var,"in prediction data set"))
        #add missing levels
        if(length(setdiff(Vvar,Vsub))>0){
            #Vret <- factor(env$Newdata[,var],levels=c(levels(factor(env$Newdata[,var])),setdiff(Vvar,Vsub)))
            Vret <- factor(env$Newdata[,var],levels=Vvar)
            Lret <- list(Vret)
            names(Lret) <- var
            return(Lret)
        }
        else return(Lret)
    }
	#trim off response from formula so model.matrix works
	newform <- as.formula(paste("~",paste(all.vars(env$Formula)[-1],collapse="+")))
	#do level check on each character/factor variable
#	env$Newdata <- as.data.frame(lapply(all.vars(newform),flev))
	checkdata <- as.data.frame(lapply(all.vars(newform),flev))
	Msub <- TEAConformMatrix(model.matrix(newform,checkdata),env$Mmod)
	#get parameter rows
	#Vrow <- sample(1:nrow(Fit),nrow(Msub),replace=TRUE)
	#same row for all!
	Vrow <- rep(sample(1:nrow(env$Fit),1),nrow(Msub))
	#betas
	Mbeta <- env$Fit[Vrow,-ncol(env$Fit)]
	if(nrow(Msub)==1) Mbeta <- t(matrix(Mbeta)) #handle vector beta for a single row
	Vsig <- sqrt(env$Fit[Vrow,ncol(env$Fit)]) #sigma
	Vmu <- diag(Msub %*% t(Mbeta))
	Vdraw <- rnorm(nrow(Msub),Vmu,Vsig)

	lhs <- all.vars(env$Formula)[1]
	DFret <- env$Newdata
	DFret[,lhs] <- fround(Vdraw)
	return(DFret)
}

mcmc.reg <- new("apop_model", name="MCMC regression",  
                                estimate_function=TEA.MCMCregress.est, 
                                draw_function=TEA.MCMCregress.draw)
